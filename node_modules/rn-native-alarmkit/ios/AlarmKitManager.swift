import Foundation
import AlarmKit
import SwiftUI
import AppIntents

/// Live Activity intent used by AlarmKit to trigger the secondary (Snooze) action.
/// Defined in this file to ensure it is compiled into the existing CocoaPods target.
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
struct AlarmKitCountdownIntent: LiveActivityIntent {
    static var title: LocalizedStringResource = "Snooze"

    @Parameter(title: "Alarm ID")
    var alarmID: String

    func perform() async throws -> some IntentResult {
        guard let uuid = UUID(uuidString: alarmID) else {
            return .result()
        }
        try AlarmManager.shared.countdown(id: uuid)
        return .result()
    }
}

/// Live Activity intent used by AlarmKit to trigger the stop/dismiss action (when applicable).
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
struct AlarmKitStopIntent: LiveActivityIntent {
    static var title: LocalizedStringResource = "Stop"

    @Parameter(title: "Alarm ID")
    var alarmID: String

    func perform() async throws -> some IntentResult {
        guard let uuid = UUID(uuidString: alarmID) else {
            return .result()
        }
        try AlarmManager.shared.stop(id: uuid)
        return .result()
    }
}

// Metadata for alarms
nonisolated struct BasicAlarmMetadata: AlarmMetadata {
    // Empty metadata for basic alarms
}

@available(iOS 26.0, *)
class AlarmKitManager {

    weak var delegate: AlarmDelegate?
    private let manager = AlarmManager.shared
    private var alarmMetadataStore: [String: [String: Any]] = [:]

    init() {
        // Start monitoring alarms
        Task {
            await monitorAlarms()
        }
    }

    // MARK: - Authorization

    func checkAuthorization() async -> String {
        switch manager.authorizationState {
        case .notDetermined:
            return "notDetermined"
        case .authorized:
            return "authorized"
        case .denied:
            return "denied"
        @unknown default:
            return "notDetermined"
        }
    }

    func requestPermission() async throws -> Bool {
        let state = try await manager.requestAuthorization()
        return state == .authorized
    }

    // MARK: - Scheduling

    func scheduleAlarm(schedule: NSDictionary, config: NSDictionary) async throws -> [String: Any] {
        let alarmId = schedule["id"] as? String ?? UUID().uuidString
        let scheduleType = schedule["type"] as? String ?? "fixed"

        // Store metadata
        alarmMetadataStore[alarmId] = [
            "schedule": schedule,
            "config": config
        ]

        let attributes = buildAlarmAttributes(config: config)
        let uuid = UUID(uuidString: alarmId) ?? UUID()

        // AlarmKit supports true alarm scheduling via AlarmConfiguration.alarm(schedule:...)
        // Use alarm schedules for fixed/recurring to avoid timer limitations and ensure calendar dates are honored.
        let now = Date()
        let alarmSchedule = buildAlarmKitSchedule(schedule: schedule, now: now)

        // Build intents + countdownDuration for Snooze, if configured.
        // Important: `preAlert` affects behavior *before* the scheduled alert.
        // Setting `preAlert` to (e.g.) 10 minutes will prevent short-future alarms (like 2 minutes from now)
        // from ever reaching the alerting UI. For Snooze we want the duration after the user taps Snooze,
        // so we use `postAlert`.
        let snoozeSeconds = extractSnoozeSeconds(config: config)
        let countdownDuration: Alarm.CountdownDuration? = (snoozeSeconds != nil)
            ? Alarm.CountdownDuration(preAlert: nil, postAlert: snoozeSeconds)
            : nil

        var stopIntentValue = AlarmKitStopIntent()
        stopIntentValue.alarmID = uuid.uuidString
        let stopIntent: (any LiveActivityIntent)? = stopIntentValue

        let secondaryIntent: (any LiveActivityIntent)? = {
            guard snoozeSeconds != nil else { return nil }
            var intent = AlarmKitCountdownIntent()
            intent.alarmID = uuid.uuidString
            return intent
        }()

        let alarm: Alarm
        if scheduleType == "interval" {
            // Interval countdown-style timers still use .timer
            let duration = calculateDuration(schedule: schedule)
            alarm = try await manager.schedule(
                id: uuid,
                configuration: .timer(
                    duration: duration,
                    attributes: attributes,
                    stopIntent: stopIntent,
                    secondaryIntent: secondaryIntent
                )
            )
        } else {
            // Use full initializer so we can pass countdownDuration + intents for Snooze.
            let alarmConfiguration = AlarmManager.AlarmConfiguration<BasicAlarmMetadata>(
                countdownDuration: countdownDuration,
                schedule: alarmSchedule,
                attributes: attributes,
                stopIntent: stopIntent,
                secondaryIntent: secondaryIntent
            )
            alarm = try await manager.schedule(
                id: uuid,
                configuration: alarmConfiguration
            )
        }

        let nextFireDate = resolveNextFireDateFromAlarmKitSchedule(schedule: alarmSchedule, now: now) ?? now

        // Serialize schedule to ensure date fields are numbers (not Date objects)
        let serializedSchedule = serializeSchedule(schedule)

        return [
            "id": alarmId,
            "schedule": serializedSchedule,
            "config": config,
            "nextFireDate": ISO8601DateFormatter().string(from: nextFireDate),
            "capability": "native_alarms",
            "isActive": true,
            "platformAlarmId": uuid.uuidString
        ]
    }

    func cancelAlarm(id: String) async throws {
        guard let uuid = UUID(uuidString: id) else {
            throw NSError(
                domain: "AlarmKitManager",
                code: 400,
                userInfo: [NSLocalizedDescriptionKey: "Invalid alarm ID"]
            )
        }

        // AlarmKit's cancel and stop are synchronous-throwing (not async)
        // Attempt cancel first (primary operation)
        do {
            try manager.cancel(id: uuid)
        } catch {
            // If cancel fails, still try stop as fallback
            print("[AlarmKitManager] cancel failed for \(id), attempting stop: \(error)")
        }
        
        // Best-effort stop to dismiss alarms that might be in .alerting state
        do {
            try manager.stop(id: uuid)
        } catch {
            // Ignore stop errors - it's best-effort cleanup
            print("[AlarmKitManager] stop failed for \(id) (may not be alerting): \(error)")
        }
        
        alarmMetadataStore.removeValue(forKey: id)
    }

    func cancelAllAlarms() async throws {
        let alarms = try await getAllAlarms()

        for alarm in alarms {
            if let id = alarm["id"] as? String {
                try await cancelAlarm(id: id)
            }
        }
    }

    func cancelAlarmsByCategory(category: String) async throws {
        let alarms = try await getAlarmsByCategory(category: category)

        for alarm in alarms {
            if let id = alarm["id"] as? String {
                try await cancelAlarm(id: id)
            }
        }
    }

    // MARK: - Query

    func getAlarm(id: String) async throws -> [String: Any]? {
        guard let metadata = alarmMetadataStore[id] else {
            return nil
        }

        guard let schedule = metadata["schedule"] as? NSDictionary,
              let config = metadata["config"] as? NSDictionary else {
            return nil
        }

        let duration = calculateDuration(schedule: schedule)
        let nextFireDate = Date.now.addingTimeInterval(duration)

        // Serialize schedule to ensure date fields are numbers (not Date objects)
        let serializedSchedule = serializeSchedule(schedule)

        return [
            "id": id,
            "schedule": serializedSchedule,
            "config": config,
            "nextFireDate": ISO8601DateFormatter().string(from: nextFireDate),
            "capability": "native_alarms",
            "isActive": true,
            "platformAlarmId": id
        ]
    }

    func getAllAlarms() async throws -> [[String: Any]] {
        var alarms: [[String: Any]] = []

        for (id, _) in alarmMetadataStore {
            if let alarm = try await getAlarm(id: id) {
                alarms.append(alarm)
            }
        }

        return alarms
    }

    func getAlarmsByCategory(category: String) async throws -> [[String: Any]] {
        var alarms: [[String: Any]] = []

        for (id, metadata) in alarmMetadataStore {
            guard let config = metadata["config"] as? NSDictionary,
                  let alarmCategory = config["category"] as? String,
                  alarmCategory == category else {
                continue
            }

            if let alarm = try await getAlarm(id: id) {
                alarms.append(alarm)
            }
        }

        return alarms
    }

    // MARK: - Actions

    func snoozeAlarm(id: String, minutes: Int) async throws {
        // For snooze, cancel existing and reschedule
        guard let metadata = alarmMetadataStore[id],
              let schedule = metadata["schedule"] as? NSDictionary,
              let config = metadata["config"] as? NSDictionary else {
            throw NSError(
                domain: "AlarmKitManager",
                code: 404,
                userInfo: [NSLocalizedDescriptionKey: "Alarm not found"]
            )
        }

        try await cancelAlarm(id: id)

        // Determine snooze duration: prefer from action config, fallback to parameter, then default
        var snoozeMinutes = minutes
        if let actions = config["actions"] as? [[String: Any]] {
            for action in actions {
                if let behavior = action["behavior"] as? String, behavior == "snooze" {
                    if let duration = action["snoozeDuration"] as? Int {
                        snoozeMinutes = duration
                        break
                    }
                }
            }
        }
        
        // Fallback to 10 minutes if no valid duration found
        if snoozeMinutes <= 0 {
            snoozeMinutes = 10
        }

        // Reschedule with snooze delay
        let snoozeDuration = TimeInterval(snoozeMinutes * 60)
        let attributes = buildAlarmAttributes(config: config)

        let uuid = UUID(uuidString: id) ?? UUID()
        var stopIntentForSnooze = AlarmKitStopIntent()
        stopIntentForSnooze.alarmID = uuid.uuidString
        _ = try await manager.schedule(
            id: uuid,
            configuration: .timer(
                duration: snoozeDuration,
                attributes: attributes,
                stopIntent: stopIntentForSnooze,
                secondaryIntent: {
                    var intent = AlarmKitCountdownIntent()
                    intent.alarmID = uuid.uuidString
                    return intent
                }()
            )
        )

        // Restore metadata
        alarmMetadataStore[id] = metadata
    }

    // MARK: - Helper Methods

    /// Map JS weekday (0=Sunday..6=Saturday) to Foundation.Locale.Weekday
    private func mapToLocaleWeekday(_ day: Int) -> Foundation.Locale.Weekday? {
        switch day {
        case 0: return .sunday
        case 1: return .monday
        case 2: return .tuesday
        case 3: return .wednesday
        case 4: return .thursday
        case 5: return .friday
        case 6: return .saturday
        default: return nil
        }
    }

    /// Build an AlarmKit Alarm.Schedule from our JS schedule dictionary.
    /// - For fixed alarms: prefer schedule.date; otherwise compute next occurrence from time.
    /// - For weekly recurring: use AlarmKit's relative weekly recurrence.
    /// - For other recurring: schedule the next occurrence as a fixed date; monitorAlarms will reschedule after fire.
    private func buildAlarmKitSchedule(schedule: NSDictionary, now: Date) -> Alarm.Schedule? {
        let scheduleType = schedule["type"] as? String ?? "fixed"

        if scheduleType == "fixed" {
            if let fixedDate = extractDate(from: schedule["date"]) {
                return .fixed(fixedDate)
            }
            // No explicit date: compute today/tomorrow at time
            if let computed = computeNextDateFromTime(schedule: schedule, from: now) {
                return .fixed(computed)
            }
            return nil
        }

        if scheduleType == "recurring" {
            let repeatInterval = schedule["repeatInterval"] as? String
            let timeDict = schedule["time"] as? NSDictionary
            let hour = timeDict?["hour"] as? Int ?? 8
            let minute = timeDict?["minute"] as? Int ?? 0

            if repeatInterval == "weekly",
               let days = schedule["daysOfWeek"] as? [Int],
               !days.isEmpty {
                let weekdays: [Foundation.Locale.Weekday] = days.compactMap { mapToLocaleWeekday($0) }
                let rel = Alarm.Schedule.Relative(
                    time: Alarm.Schedule.Relative.Time(hour: hour, minute: minute),
                    repeats: .weekly(weekdays)
                )
                return .relative(rel)
            }

            // For daily/monthly/yearly (and any other future intervals), schedule the next occurrence as fixed.
            if let startDate = extractDate(from: schedule["startDate"]), startDate > now {
                return .fixed(startDate)
            }
            if let next = calculateNextOccurrenceDate(schedule: schedule, fromDate: now) {
                return .fixed(next)
            }
            // Fallback: schedule next from time today/tomorrow
            if let computed = computeNextDateFromTime(schedule: schedule, from: now) {
                return .fixed(computed)
            }
            return nil
        }

        // interval handled elsewhere; return nil here
        return nil
    }

    /// Compute next date from schedule.time (today at hour/minute or tomorrow if passed).
    private func computeNextDateFromTime(schedule: NSDictionary, from now: Date) -> Date? {
        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        var components = calendar.dateComponents([.year, .month, .day], from: now)
        components.hour = hour
        components.minute = minute
        components.second = 0

        guard var target = calendar.date(from: components) else { return nil }
        if target <= now {
            target = calendar.date(byAdding: .day, value: 1, to: target) ?? target
        }
        return target
    }

    /// Resolve a best-effort next fire date for returning to JS.
    private func resolveNextFireDateFromAlarmKitSchedule(schedule: Alarm.Schedule?, now: Date) -> Date? {
        guard let schedule = schedule else { return nil }
        switch schedule {
        case .fixed(let date):
            return date
        case .relative(let rel):
            // Compute next matching weekday/time from now
            let hour = rel.time.hour
            let minute = rel.time.minute
            var calendar = Calendar.current
            calendar.timeZone = TimeZone.current

            switch rel.repeats {
            case .weekly(let weekdays):
                // Convert Locale.Weekday to Calendar weekday ints (1=Sunday..7=Saturday)
                let allowed: Set<Int> = Set(weekdays.compactMap { wd in
                    switch wd {
                    case .sunday: return 1
                    case .monday: return 2
                    case .tuesday: return 3
                    case .wednesday: return 4
                    case .thursday: return 5
                    case .friday: return 6
                    case .saturday: return 7
                    }
                })

                for i in 0...14 {
                    guard let day = calendar.date(byAdding: .day, value: i, to: now) else { continue }
                    let weekday = calendar.component(.weekday, from: day)
                    if allowed.contains(weekday) {
                        var comps = calendar.dateComponents([.year, .month, .day], from: day)
                        comps.hour = hour
                        comps.minute = minute
                        comps.second = 0
                        if let candidate = calendar.date(from: comps), candidate > now {
                            return candidate
                        }
                    }
                }
                return nil
            case .never:
                // Next occurrence today/tomorrow
                return computeNextDateFromTime(schedule: ["time": ["hour": hour, "minute": minute]] as NSDictionary, from: now)
            }
        }
    }

    /// Extract Date from various possible types in NSDictionary (Double, NSNumber, Date, ISO string)
    private func extractDate(from value: Any?) -> Date? {
        guard let value = value else { return nil }
        
        // Try Double (milliseconds timestamp)
        if let timestamp = value as? Double {
            return Date(timeIntervalSince1970: timestamp / 1000.0)
        }
        
        // Try NSNumber (milliseconds timestamp)
        if let number = value as? NSNumber {
            return Date(timeIntervalSince1970: number.doubleValue / 1000.0)
        }
        
        // Try Date/NSDate directly
        if let date = value as? Date {
            return date
        }
        
        // Try ISO string
        if let isoString = value as? String {
            let formatter = ISO8601DateFormatter()
            return formatter.date(from: isoString)
        }
        
        return nil
    }

    /// Serialize schedule dictionary, ensuring date fields are numbers (milliseconds) for JSON serialization
    private func serializeSchedule(_ schedule: NSDictionary) -> NSDictionary {
        let mutable = NSMutableDictionary(dictionary: schedule)
        
        // Convert date fields to milliseconds (numbers) if they exist
        if let date = extractDate(from: schedule["date"]) {
            mutable["date"] = date.timeIntervalSince1970 * 1000.0
        }
        if let startDate = extractDate(from: schedule["startDate"]) {
            mutable["startDate"] = startDate.timeIntervalSince1970 * 1000.0
        }
        if let startTime = extractDate(from: schedule["startTime"]) {
            mutable["startTime"] = startTime.timeIntervalSince1970 * 1000.0
        }
        
        return mutable
    }

    private func calculateDuration(schedule: NSDictionary) -> TimeInterval {
        let scheduleType = schedule["type"] as? String ?? "fixed"

        if scheduleType == "interval", let intervalMinutes = schedule["intervalMinutes"] as? Int {
            return TimeInterval(intervalMinutes * 60)
        }

        // For fixed alarms with a specific date, use that date
        if scheduleType == "fixed" {
            if let dateValue = extractDate(from: schedule["date"]) {
                let now = Date()
                let duration = dateValue.timeIntervalSince(now)
                // Ensure duration is non-negative (if date is in past, schedule for 1 hour from now)
                if duration > 0 {
                    return duration
                } else {
                    // Date is in the past, log for debugging
                    print("[AlarmKitManager] Warning: Fixed alarm date is in the past: \(dateValue)")
                    return 3600 // Default 1 hour
                }
            } else {
                // Debug logging: log what type we actually got
                if let dateObj = schedule["date"] {
                    let typeName = String(describing: Swift.type(of: dateObj))
                    print("[AlarmKitManager] Warning: Could not extract date from schedule[\"date\"], type: \(typeName), value: \(dateObj)")
                }
            }
        }

        // For fixed without date, or recurring, calculate time until next alarm
        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        let now = Date()
        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        // For recurring alarms, check if there's a startDate to anchor the series
        var targetDate: Date?
        if let startDate = extractDate(from: schedule["startDate"]) {
            // If startDate is in the future, use it as the first occurrence
            if startDate > now {
                targetDate = startDate
            }
        }

        // If no targetDate yet, calculate next occurrence
        if targetDate == nil {
            var components = calendar.dateComponents([.year, .month, .day], from: now)
            components.hour = hour
            components.minute = minute
            components.second = 0

            guard let baseDate = calendar.date(from: components) else {
                return 3600 // Default 1 hour
            }

            targetDate = baseDate

            // If time has passed today, schedule for tomorrow
            if targetDate! <= now {
                targetDate = calendar.date(byAdding: .day, value: 1, to: targetDate!)
            }
        }

        guard let finalTargetDate = targetDate else {
            return 3600 // Default 1 hour
        }

        return finalTargetDate.timeIntervalSince(now)
    }

    private func calculateNextOccurrenceDate(schedule: NSDictionary, fromDate: Date) -> Date? {
        let scheduleType = schedule["type"] as? String ?? "fixed"
        let repeatInterval = schedule["repeatInterval"] as? String

        // For non-recurring alarms, return nil (no next occurrence)
        if scheduleType == "fixed" && repeatInterval == nil {
            return nil
        }

        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        switch repeatInterval {
        case "daily":
            // Next occurrence is tomorrow at the same time
            var components = calendar.dateComponents([.year, .month, .day, .hour, .minute], from: fromDate)
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            guard let baseDate = calendar.date(from: components) else { return nil }
            
            // If baseDate is today and time hasn't passed, use it; otherwise use tomorrow
            if baseDate <= fromDate {
                return calendar.date(byAdding: .day, value: 1, to: baseDate)
            }
            return baseDate

        case "weekly":
            // Find next occurrence on the specified weekday
            let daysOfWeek = schedule["daysOfWeek"] as? [Int] ?? []
            guard !daysOfWeek.isEmpty else { return nil }
            
            let currentWeekday = calendar.component(.weekday, from: fromDate) - 1 // Convert to 0-6 (Sunday=0)
            
            // Find the next matching weekday
            for i in 1...14 { // Check up to 2 weeks ahead
                guard let checkDate = calendar.date(byAdding: .day, value: i, to: fromDate) else {
                    continue
                }
                let checkWeekday = calendar.component(.weekday, from: checkDate) - 1
                
                if daysOfWeek.contains(checkWeekday) {
                    var components = calendar.dateComponents([.year, .month, .day], from: checkDate)
                    components.hour = hour
                    components.minute = minute
                    components.second = 0
                    return calendar.date(from: components)
                }
            }
            return nil

        case "monthly":
            // Next occurrence on the same day of month next month
            let dayOfMonth = schedule["dayOfMonth"] as? Int ?? calendar.component(.day, from: fromDate)
            
            var components = calendar.dateComponents([.year, .month, .day], from: fromDate)
            let currentMonth = components.month ?? 1
            components.month = currentMonth + 1
            if components.month! > 12 {
                components.month = 1
                components.year = (components.year ?? 2024) + 1
            }
            
            // Handle invalid days (e.g., 31st in February)
            // Clamp to last valid day of month
            guard let tempDate = calendar.date(from: components),
                  let dayRange = calendar.range(of: .day, in: .month, for: tempDate) else {
                return nil
            }
            let clampedDay = min(dayOfMonth, dayRange.upperBound - 1)
            components.day = clampedDay
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            return calendar.date(from: components)

        case "yearly":
            // Next occurrence on the same month/day next year
            let monthOfYear = schedule["monthOfYear"] as? Int ?? calendar.component(.month, from: fromDate)
            let dayOfMonth = schedule["dayOfMonth"] as? Int ?? calendar.component(.day, from: fromDate)
            
            var components = calendar.dateComponents([.year, .month, .day], from: fromDate)
            components.year = (components.year ?? 2024) + 1
            components.month = monthOfYear
            
            // Handle invalid days (e.g., Feb 29 in non-leap year)
            guard let tempDate = calendar.date(from: components),
                  let dayRange = calendar.range(of: .day, in: .month, for: tempDate) else {
                return nil
            }
            let clampedDay = min(dayOfMonth, dayRange.upperBound - 1)
            components.day = clampedDay
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            return calendar.date(from: components)

        default:
            return nil
        }
    }

    private func buildAlarmAttributes(config: NSDictionary) -> AlarmAttributes<BasicAlarmMetadata> {
        let title = config["title"] as? String ?? "Alarm"
        let colorHex = config["color"] as? String ?? "#007AFF"
        let tintColor = hexToColor(colorHex)
        let buttonTextColor: Color = .white 

        // Parse actions from config
        var dismissAction: [String: Any]? = nil
        var snoozeAction: [String: Any]? = nil
        
        if let actions = config["actions"] as? [[String: Any]] {
            for action in actions {
                let behavior = action["behavior"] as? String ?? ""
                if behavior == "dismiss" && dismissAction == nil {
                    dismissAction = action
                } else if behavior == "snooze" && snoozeAction == nil {
                    snoozeAction = action
                }
            }
        }

        // NOTE (iOS 26.1+): AlarmKit's `stopButton` is deprecated and "will no longer be used".
        // The system provides its own dismiss control (the X youâ€™re seeing).
        //
        // We still read the JS "dismiss" action, but we can't reliably customize the system dismiss UI.
        // Primary goal: show Snooze via AlarmKit's `secondaryButton`.

        let titleResource = LocalizedStringResource(stringLiteral: title)

        // Build secondary (snooze) button if provided
        var secondaryButton: AlarmButton? = nil
        var secondaryBehavior: AlarmPresentation.Alert.SecondaryButtonBehavior? = nil

        if let snooze = snoozeAction {
            let snoozeButtonText = snooze["title"] as? String ?? "Snooze"
            // Use a known-good SF Symbol fallback to avoid AlarmKit rejecting the configuration.
            let snoozeButtonIcon = snooze["icon"] as? String ?? "clock.arrow.circlepath"
            secondaryButton = AlarmButton(
                text: LocalizedStringResource(stringLiteral: snoozeButtonText),
                textColor: buttonTextColor,
                systemImageName: snoozeButtonIcon
            )
            // For snooze, the correct behavior is countdown.
            secondaryBehavior = .countdown
        }

        let alert: AlarmPresentation.Alert
        if #available(iOS 26.1, *) {
            // New initializer (no stop button)
            alert = AlarmPresentation.Alert(
                title: titleResource,
                secondaryButton: secondaryButton,
                secondaryButtonBehavior: secondaryBehavior
            )
        } else {
            // iOS 26.0 fallback: stopButton initializer still exists (deprecated in 26.1)
            let stopButtonText = (dismissAction?["title"] as? String) ?? "Done"
            let stopButtonIcon = (dismissAction?["icon"] as? String) ?? "checkmark.circle.fill"
            let stopButton = AlarmButton(
                text: LocalizedStringResource(stringLiteral: stopButtonText),
                textColor: buttonTextColor,
                systemImageName: stopButtonIcon
            )
            alert = AlarmPresentation.Alert(
                title: titleResource,
                stopButton: stopButton,
                secondaryButton: secondaryButton,
                secondaryButtonBehavior: secondaryBehavior
            )
        }

        // Provide Countdown/Paused presentations when snooze is enabled.
        // Without these, the Snooze tap can become a no-op (UI presses but alarm remains alerting).
        let presentation: AlarmPresentation
        if secondaryButton != nil {
            let countdown = AlarmPresentation.Countdown(
                title: LocalizedStringResource(stringLiteral: "Snoozed"),
                pauseButton: AlarmButton(
                    text: LocalizedStringResource(stringLiteral: "Pause"),
                    textColor: tintColor,
                    systemImageName: "pause.fill"
                )
            )
            let paused = AlarmPresentation.Paused(
                title: LocalizedStringResource(stringLiteral: "Snoozed"),
                resumeButton: AlarmButton(
                    text: LocalizedStringResource(stringLiteral: "Resume"),
                    textColor: buttonTextColor,
                    systemImageName: "play.fill"
                )
            )
            presentation = AlarmPresentation(alert: alert, countdown: countdown, paused: paused)
        } else {
            presentation = AlarmPresentation(alert: alert)
        }

        let attributes = AlarmAttributes<BasicAlarmMetadata>(
            presentation: presentation,
            tintColor: tintColor
        )

        return attributes
    }

    /// Extract Snooze duration (seconds) from JS config actions.
    /// Returns nil when no snooze action exists.
    private func extractSnoozeSeconds(config: NSDictionary) -> TimeInterval? {
        guard let actions = config["actions"] as? [[String: Any]] else { return nil }
        for action in actions {
            if let behavior = action["behavior"] as? String, behavior == "snooze" {
                // JS provides minutes; convert to seconds
                if let minutes = action["snoozeDuration"] as? Int, minutes > 0 {
                    return TimeInterval(minutes * 60)
                }
                if let minutesNumber = action["snoozeDuration"] as? NSNumber, minutesNumber.intValue > 0 {
                    return TimeInterval(minutesNumber.intValue * 60)
                }
                // Default snooze duration if action exists but missing duration
                return 10 * 60
            }
        }
        return nil
    }

    private func hexToColor(_ hex: String) -> Color {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")

        var rgb: UInt64 = 0
        Scanner(string: hexSanitized).scanHexInt64(&rgb)

        let red = Double((rgb & 0xFF0000) >> 16) / 255.0
        let green = Double((rgb & 0x00FF00) >> 8) / 255.0
        let blue = Double(rgb & 0x0000FF) / 255.0

        return Color(red: red, green: green, blue: blue)
    }

    private func monitorAlarms() async {
        for await alarms in manager.alarmUpdates {
            for alarm in alarms {
                if alarm.state == .alerting {
                    let alarmId = alarm.id.uuidString

                    if let metadata = alarmMetadataStore[alarmId],
                       let schedule = metadata["schedule"] as? NSDictionary,
                       let config = metadata["config"] as? NSDictionary {

                        // Serialize schedule to ensure date fields are numbers (not Date objects)
                        let serializedSchedule = serializeSchedule(schedule)

                        let alarmData: [String: Any] = [
                            "id": alarmId,
                            "schedule": serializedSchedule,
                            "config": config,
                            "nextFireDate": ISO8601DateFormatter().string(from: Date()),
                            "capability": "native_alarms",
                            "isActive": true
                        ]

                        delegate?.alarmDidFire(alarm: alarmData)

                        // For recurring alarms, reschedule the next occurrence (except weekly, which AlarmKit can handle natively)
                        let scheduleType = schedule["type"] as? String ?? "fixed"
                        let repeatInterval = schedule["repeatInterval"] as? String
                        
                        if scheduleType == "recurring" && repeatInterval != nil && repeatInterval != "weekly" {
                            let now = Date()
                            if let nextOccurrence = calculateNextOccurrenceDate(schedule: schedule, fromDate: now) {
                                // Reschedule for next occurrence using AlarmKit fixed-date alarms
                                let attributes = buildAlarmAttributes(config: config)
                                let uuid = UUID(uuidString: alarmId) ?? UUID()
                                do {
                                    _ = try await manager.schedule(
                                        id: uuid,
                                        configuration: .alarm(
                                            schedule: .fixed(nextOccurrence),
                                            attributes: attributes
                                        )
                                    )
                                } catch {
                                    print("Failed to reschedule recurring alarm \(alarmId): \(error)")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
