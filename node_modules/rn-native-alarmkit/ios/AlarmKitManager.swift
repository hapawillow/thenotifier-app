import Foundation
import AlarmKit
import SwiftUI

// Metadata for alarms
nonisolated struct BasicAlarmMetadata: AlarmMetadata {
    // Empty metadata for basic alarms
}

@available(iOS 26.0, *)
class AlarmKitManager {

    weak var delegate: AlarmDelegate?
    private let manager = AlarmManager.shared
    private var alarmMetadataStore: [String: [String: Any]] = [:]

    init() {
        // Start monitoring alarms
        Task {
            await monitorAlarms()
        }
    }

    // MARK: - Authorization

    func checkAuthorization() async -> String {
        switch manager.authorizationState {
        case .notDetermined:
            return "notDetermined"
        case .authorized:
            return "authorized"
        case .denied:
            return "denied"
        @unknown default:
            return "notDetermined"
        }
    }

    func requestPermission() async throws -> Bool {
        let state = try await manager.requestAuthorization()
        return state == .authorized
    }

    // MARK: - Scheduling

    func scheduleAlarm(schedule: NSDictionary, config: NSDictionary) async throws -> [String: Any] {
        let alarmId = schedule["id"] as? String ?? UUID().uuidString
        let scheduleType = schedule["type"] as? String ?? "fixed"

        // Store metadata
        alarmMetadataStore[alarmId] = [
            "schedule": schedule,
            "config": config
        ]

        let attributes = buildAlarmAttributes(config: config)
        let uuid = UUID(uuidString: alarmId) ?? UUID()

        // AlarmKit supports true alarm scheduling via AlarmConfiguration.alarm(schedule:...)
        // Use alarm schedules for fixed/recurring to avoid timer limitations and ensure calendar dates are honored.
        let now = Date()
        let alarmSchedule = buildAlarmKitSchedule(schedule: schedule, now: now)

        let alarm: Alarm
        if scheduleType == "interval" {
            // Interval countdown-style timers still use .timer
            let duration = calculateDuration(schedule: schedule)
            alarm = try await manager.schedule(
                id: uuid,
                configuration: .timer(
                    duration: duration,
                    attributes: attributes
                )
            )
        } else {
            alarm = try await manager.schedule(
                id: uuid,
                configuration: .alarm(
                    schedule: alarmSchedule,
                    attributes: attributes
                )
            )
        }

        let nextFireDate = resolveNextFireDateFromAlarmKitSchedule(schedule: alarmSchedule, now: now) ?? now

        // Serialize schedule to ensure date fields are numbers (not Date objects)
        let serializedSchedule = serializeSchedule(schedule)

        return [
            "id": alarmId,
            "schedule": serializedSchedule,
            "config": config,
            "nextFireDate": ISO8601DateFormatter().string(from: nextFireDate),
            "capability": "native_alarms",
            "isActive": true,
            "platformAlarmId": uuid.uuidString
        ]
    }

    func cancelAlarm(id: String) async throws {
        guard let uuid = UUID(uuidString: id) else {
            throw NSError(
                domain: "AlarmKitManager",
                code: 400,
                userInfo: [NSLocalizedDescriptionKey: "Invalid alarm ID"]
            )
        }

        // AlarmKit's cancel and stop are synchronous-throwing (not async)
        // Attempt cancel first (primary operation)
        do {
            try manager.cancel(id: uuid)
        } catch {
            // If cancel fails, still try stop as fallback
            print("[AlarmKitManager] cancel failed for \(id), attempting stop: \(error)")
        }
        
        // Best-effort stop to dismiss alarms that might be in .alerting state
        do {
            try manager.stop(id: uuid)
        } catch {
            // Ignore stop errors - it's best-effort cleanup
            print("[AlarmKitManager] stop failed for \(id) (may not be alerting): \(error)")
        }
        
        alarmMetadataStore.removeValue(forKey: id)
    }

    func cancelAllAlarms() async throws {
        let alarms = try await getAllAlarms()

        for alarm in alarms {
            if let id = alarm["id"] as? String {
                try await cancelAlarm(id: id)
            }
        }
    }

    func cancelAlarmsByCategory(category: String) async throws {
        let alarms = try await getAlarmsByCategory(category: category)

        for alarm in alarms {
            if let id = alarm["id"] as? String {
                try await cancelAlarm(id: id)
            }
        }
    }

    // MARK: - Query

    func getAlarm(id: String) async throws -> [String: Any]? {
        guard let metadata = alarmMetadataStore[id] else {
            return nil
        }

        guard let schedule = metadata["schedule"] as? NSDictionary,
              let config = metadata["config"] as? NSDictionary else {
            return nil
        }

        let duration = calculateDuration(schedule: schedule)
        let nextFireDate = Date.now.addingTimeInterval(duration)

        // Serialize schedule to ensure date fields are numbers (not Date objects)
        let serializedSchedule = serializeSchedule(schedule)

        return [
            "id": id,
            "schedule": serializedSchedule,
            "config": config,
            "nextFireDate": ISO8601DateFormatter().string(from: nextFireDate),
            "capability": "native_alarms",
            "isActive": true,
            "platformAlarmId": id
        ]
    }

    func getAllAlarms() async throws -> [[String: Any]] {
        var alarms: [[String: Any]] = []

        for (id, _) in alarmMetadataStore {
            if let alarm = try await getAlarm(id: id) {
                alarms.append(alarm)
            }
        }

        return alarms
    }

    func getAlarmsByCategory(category: String) async throws -> [[String: Any]] {
        var alarms: [[String: Any]] = []

        for (id, metadata) in alarmMetadataStore {
            guard let config = metadata["config"] as? NSDictionary,
                  let alarmCategory = config["category"] as? String,
                  alarmCategory == category else {
                continue
            }

            if let alarm = try await getAlarm(id: id) {
                alarms.append(alarm)
            }
        }

        return alarms
    }

    // MARK: - Actions

    func snoozeAlarm(id: String, minutes: Int) async throws {
        // For snooze, cancel existing and reschedule
        guard let metadata = alarmMetadataStore[id],
              let schedule = metadata["schedule"] as? NSDictionary,
              let config = metadata["config"] as? NSDictionary else {
            throw NSError(
                domain: "AlarmKitManager",
                code: 404,
                userInfo: [NSLocalizedDescriptionKey: "Alarm not found"]
            )
        }

        try await cancelAlarm(id: id)

        // Reschedule with snooze delay
        let snoozeDuration = TimeInterval(minutes * 60)
        let attributes = buildAlarmAttributes(config: config)

        let uuid = UUID(uuidString: id) ?? UUID()
        _ = try await manager.schedule(
            id: uuid,
            configuration: .timer(
                duration: snoozeDuration,
                attributes: attributes
            )
        )

        // Restore metadata
        alarmMetadataStore[id] = metadata
    }

    // MARK: - Helper Methods

    /// Map JS weekday (0=Sunday..6=Saturday) to Foundation.Locale.Weekday
    private func mapToLocaleWeekday(_ day: Int) -> Foundation.Locale.Weekday? {
        switch day {
        case 0: return .sunday
        case 1: return .monday
        case 2: return .tuesday
        case 3: return .wednesday
        case 4: return .thursday
        case 5: return .friday
        case 6: return .saturday
        default: return nil
        }
    }

    /// Build an AlarmKit Alarm.Schedule from our JS schedule dictionary.
    /// - For fixed alarms: prefer schedule.date; otherwise compute next occurrence from time.
    /// - For weekly recurring: use AlarmKit's relative weekly recurrence.
    /// - For other recurring: schedule the next occurrence as a fixed date; monitorAlarms will reschedule after fire.
    private func buildAlarmKitSchedule(schedule: NSDictionary, now: Date) -> Alarm.Schedule? {
        let scheduleType = schedule["type"] as? String ?? "fixed"

        if scheduleType == "fixed" {
            if let fixedDate = extractDate(from: schedule["date"]) {
                return .fixed(fixedDate)
            }
            // No explicit date: compute today/tomorrow at time
            if let computed = computeNextDateFromTime(schedule: schedule, from: now) {
                return .fixed(computed)
            }
            return nil
        }

        if scheduleType == "recurring" {
            let repeatInterval = schedule["repeatInterval"] as? String
            let timeDict = schedule["time"] as? NSDictionary
            let hour = timeDict?["hour"] as? Int ?? 8
            let minute = timeDict?["minute"] as? Int ?? 0

            if repeatInterval == "weekly",
               let days = schedule["daysOfWeek"] as? [Int],
               !days.isEmpty {
                let weekdays: [Foundation.Locale.Weekday] = days.compactMap { mapToLocaleWeekday($0) }
                let rel = Alarm.Schedule.Relative(
                    time: Alarm.Schedule.Relative.Time(hour: hour, minute: minute),
                    repeats: .weekly(weekdays)
                )
                return .relative(rel)
            }

            // For daily/monthly/yearly (and any other future intervals), schedule the next occurrence as fixed.
            if let startDate = extractDate(from: schedule["startDate"]), startDate > now {
                return .fixed(startDate)
            }
            if let next = calculateNextOccurrenceDate(schedule: schedule, fromDate: now) {
                return .fixed(next)
            }
            // Fallback: schedule next from time today/tomorrow
            if let computed = computeNextDateFromTime(schedule: schedule, from: now) {
                return .fixed(computed)
            }
            return nil
        }

        // interval handled elsewhere; return nil here
        return nil
    }

    /// Compute next date from schedule.time (today at hour/minute or tomorrow if passed).
    private func computeNextDateFromTime(schedule: NSDictionary, from now: Date) -> Date? {
        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        var components = calendar.dateComponents([.year, .month, .day], from: now)
        components.hour = hour
        components.minute = minute
        components.second = 0

        guard var target = calendar.date(from: components) else { return nil }
        if target <= now {
            target = calendar.date(byAdding: .day, value: 1, to: target) ?? target
        }
        return target
    }

    /// Resolve a best-effort next fire date for returning to JS.
    private func resolveNextFireDateFromAlarmKitSchedule(schedule: Alarm.Schedule?, now: Date) -> Date? {
        guard let schedule = schedule else { return nil }
        switch schedule {
        case .fixed(let date):
            return date
        case .relative(let rel):
            // Compute next matching weekday/time from now
            let hour = rel.time.hour
            let minute = rel.time.minute
            var calendar = Calendar.current
            calendar.timeZone = TimeZone.current

            switch rel.repeats {
            case .weekly(let weekdays):
                // Convert Locale.Weekday to Calendar weekday ints (1=Sunday..7=Saturday)
                let allowed: Set<Int> = Set(weekdays.compactMap { wd in
                    switch wd {
                    case .sunday: return 1
                    case .monday: return 2
                    case .tuesday: return 3
                    case .wednesday: return 4
                    case .thursday: return 5
                    case .friday: return 6
                    case .saturday: return 7
                    }
                })

                for i in 0...14 {
                    guard let day = calendar.date(byAdding: .day, value: i, to: now) else { continue }
                    let weekday = calendar.component(.weekday, from: day)
                    if allowed.contains(weekday) {
                        var comps = calendar.dateComponents([.year, .month, .day], from: day)
                        comps.hour = hour
                        comps.minute = minute
                        comps.second = 0
                        if let candidate = calendar.date(from: comps), candidate > now {
                            return candidate
                        }
                    }
                }
                return nil
            case .never:
                // Next occurrence today/tomorrow
                return computeNextDateFromTime(schedule: ["time": ["hour": hour, "minute": minute]] as NSDictionary, from: now)
            }
        }
    }

    /// Extract Date from various possible types in NSDictionary (Double, NSNumber, Date, ISO string)
    private func extractDate(from value: Any?) -> Date? {
        guard let value = value else { return nil }
        
        // Try Double (milliseconds timestamp)
        if let timestamp = value as? Double {
            return Date(timeIntervalSince1970: timestamp / 1000.0)
        }
        
        // Try NSNumber (milliseconds timestamp)
        if let number = value as? NSNumber {
            return Date(timeIntervalSince1970: number.doubleValue / 1000.0)
        }
        
        // Try Date/NSDate directly
        if let date = value as? Date {
            return date
        }
        
        // Try ISO string
        if let isoString = value as? String {
            let formatter = ISO8601DateFormatter()
            return formatter.date(from: isoString)
        }
        
        return nil
    }

    /// Serialize schedule dictionary, ensuring date fields are numbers (milliseconds) for JSON serialization
    private func serializeSchedule(_ schedule: NSDictionary) -> NSDictionary {
        let mutable = NSMutableDictionary(dictionary: schedule)
        
        // Convert date fields to milliseconds (numbers) if they exist
        if let date = extractDate(from: schedule["date"]) {
            mutable["date"] = date.timeIntervalSince1970 * 1000.0
        }
        if let startDate = extractDate(from: schedule["startDate"]) {
            mutable["startDate"] = startDate.timeIntervalSince1970 * 1000.0
        }
        if let startTime = extractDate(from: schedule["startTime"]) {
            mutable["startTime"] = startTime.timeIntervalSince1970 * 1000.0
        }
        
        return mutable
    }

    private func calculateDuration(schedule: NSDictionary) -> TimeInterval {
        let scheduleType = schedule["type"] as? String ?? "fixed"

        if scheduleType == "interval", let intervalMinutes = schedule["intervalMinutes"] as? Int {
            return TimeInterval(intervalMinutes * 60)
        }

        // For fixed alarms with a specific date, use that date
        if scheduleType == "fixed" {
            if let dateValue = extractDate(from: schedule["date"]) {
                let now = Date()
                let duration = dateValue.timeIntervalSince(now)
                // Ensure duration is non-negative (if date is in past, schedule for 1 hour from now)
                if duration > 0 {
                    return duration
                } else {
                    // Date is in the past, log for debugging
                    print("[AlarmKitManager] Warning: Fixed alarm date is in the past: \(dateValue)")
                    return 3600 // Default 1 hour
                }
            } else {
                // Debug logging: log what type we actually got
                if let dateObj = schedule["date"] {
                    let typeName = String(describing: Swift.type(of: dateObj))
                    print("[AlarmKitManager] Warning: Could not extract date from schedule[\"date\"], type: \(typeName), value: \(dateObj)")
                }
            }
        }

        // For fixed without date, or recurring, calculate time until next alarm
        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        let now = Date()
        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        // For recurring alarms, check if there's a startDate to anchor the series
        var targetDate: Date?
        if let startDate = extractDate(from: schedule["startDate"]) {
            // If startDate is in the future, use it as the first occurrence
            if startDate > now {
                targetDate = startDate
            }
        }

        // If no targetDate yet, calculate next occurrence
        if targetDate == nil {
            var components = calendar.dateComponents([.year, .month, .day], from: now)
            components.hour = hour
            components.minute = minute
            components.second = 0

            guard let baseDate = calendar.date(from: components) else {
                return 3600 // Default 1 hour
            }

            targetDate = baseDate

            // If time has passed today, schedule for tomorrow
            if targetDate! <= now {
                targetDate = calendar.date(byAdding: .day, value: 1, to: targetDate!)
            }
        }

        guard let finalTargetDate = targetDate else {
            return 3600 // Default 1 hour
        }

        return finalTargetDate.timeIntervalSince(now)
    }

    private func calculateNextOccurrenceDate(schedule: NSDictionary, fromDate: Date) -> Date? {
        let scheduleType = schedule["type"] as? String ?? "fixed"
        let repeatInterval = schedule["repeatInterval"] as? String

        // For non-recurring alarms, return nil (no next occurrence)
        if scheduleType == "fixed" && repeatInterval == nil {
            return nil
        }

        let time = schedule["time"] as? NSDictionary
        let hour = time?["hour"] as? Int ?? 8
        let minute = time?["minute"] as? Int ?? 0

        var calendar = Calendar.current
        calendar.timeZone = TimeZone.current

        switch repeatInterval {
        case "daily":
            // Next occurrence is tomorrow at the same time
            var components = calendar.dateComponents([.year, .month, .day, .hour, .minute], from: fromDate)
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            guard let baseDate = calendar.date(from: components) else { return nil }
            
            // If baseDate is today and time hasn't passed, use it; otherwise use tomorrow
            if baseDate <= fromDate {
                return calendar.date(byAdding: .day, value: 1, to: baseDate)
            }
            return baseDate

        case "weekly":
            // Find next occurrence on the specified weekday
            let daysOfWeek = schedule["daysOfWeek"] as? [Int] ?? []
            guard !daysOfWeek.isEmpty else { return nil }
            
            let currentWeekday = calendar.component(.weekday, from: fromDate) - 1 // Convert to 0-6 (Sunday=0)
            
            // Find the next matching weekday
            for i in 1...14 { // Check up to 2 weeks ahead
                guard let checkDate = calendar.date(byAdding: .day, value: i, to: fromDate) else {
                    continue
                }
                let checkWeekday = calendar.component(.weekday, from: checkDate) - 1
                
                if daysOfWeek.contains(checkWeekday) {
                    var components = calendar.dateComponents([.year, .month, .day], from: checkDate)
                    components.hour = hour
                    components.minute = minute
                    components.second = 0
                    return calendar.date(from: components)
                }
            }
            return nil

        case "monthly":
            // Next occurrence on the same day of month next month
            let dayOfMonth = schedule["dayOfMonth"] as? Int ?? calendar.component(.day, from: fromDate)
            
            var components = calendar.dateComponents([.year, .month, .day], from: fromDate)
            let currentMonth = components.month ?? 1
            components.month = currentMonth + 1
            if components.month! > 12 {
                components.month = 1
                components.year = (components.year ?? 2024) + 1
            }
            
            // Handle invalid days (e.g., 31st in February)
            // Clamp to last valid day of month
            guard let tempDate = calendar.date(from: components),
                  let dayRange = calendar.range(of: .day, in: .month, for: tempDate) else {
                return nil
            }
            let clampedDay = min(dayOfMonth, dayRange.upperBound - 1)
            components.day = clampedDay
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            return calendar.date(from: components)

        case "yearly":
            // Next occurrence on the same month/day next year
            let monthOfYear = schedule["monthOfYear"] as? Int ?? calendar.component(.month, from: fromDate)
            let dayOfMonth = schedule["dayOfMonth"] as? Int ?? calendar.component(.day, from: fromDate)
            
            var components = calendar.dateComponents([.year, .month, .day], from: fromDate)
            components.year = (components.year ?? 2024) + 1
            components.month = monthOfYear
            
            // Handle invalid days (e.g., Feb 29 in non-leap year)
            guard let tempDate = calendar.date(from: components),
                  let dayRange = calendar.range(of: .day, in: .month, for: tempDate) else {
                return nil
            }
            let clampedDay = min(dayOfMonth, dayRange.upperBound - 1)
            components.day = clampedDay
            components.hour = hour
            components.minute = minute
            components.second = 0
            
            return calendar.date(from: components)

        default:
            return nil
        }
    }

    private func buildAlarmAttributes(config: NSDictionary) -> AlarmAttributes<BasicAlarmMetadata> {
        let title = config["title"] as? String ?? "Alarm"
        let colorHex = config["color"] as? String ?? "#007AFF"

        // Build stop button
        let stopButton = AlarmButton(
            text: "Done",
            textColor: hexToColor(colorHex),
            systemImageName: "checkmark.circle.fill"
        )

        // Build alert presentation
        let alert = AlarmPresentation.Alert(
            title: LocalizedStringResource(stringLiteral: title),
            stopButton: stopButton
        )

        let presentation = AlarmPresentation(alert: alert)
        let tintColor = hexToColor(colorHex)

        let attributes = AlarmAttributes<BasicAlarmMetadata>(
            presentation: presentation,
            tintColor: tintColor
        )

        return attributes
    }

    private func hexToColor(_ hex: String) -> Color {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")

        var rgb: UInt64 = 0
        Scanner(string: hexSanitized).scanHexInt64(&rgb)

        let red = Double((rgb & 0xFF0000) >> 16) / 255.0
        let green = Double((rgb & 0x00FF00) >> 8) / 255.0
        let blue = Double(rgb & 0x0000FF) / 255.0

        return Color(red: red, green: green, blue: blue)
    }

    private func monitorAlarms() async {
        for await alarms in manager.alarmUpdates {
            for alarm in alarms {
                if alarm.state == .alerting {
                    let alarmId = alarm.id.uuidString

                    if let metadata = alarmMetadataStore[alarmId],
                       let schedule = metadata["schedule"] as? NSDictionary,
                       let config = metadata["config"] as? NSDictionary {

                        // Serialize schedule to ensure date fields are numbers (not Date objects)
                        let serializedSchedule = serializeSchedule(schedule)

                        let alarmData: [String: Any] = [
                            "id": alarmId,
                            "schedule": serializedSchedule,
                            "config": config,
                            "nextFireDate": ISO8601DateFormatter().string(from: Date()),
                            "capability": "native_alarms",
                            "isActive": true
                        ]

                        delegate?.alarmDidFire(alarm: alarmData)

                        // For recurring alarms, reschedule the next occurrence (except weekly, which AlarmKit can handle natively)
                        let scheduleType = schedule["type"] as? String ?? "fixed"
                        let repeatInterval = schedule["repeatInterval"] as? String
                        
                        if scheduleType == "recurring" && repeatInterval != nil && repeatInterval != "weekly" {
                            let now = Date()
                            if let nextOccurrence = calculateNextOccurrenceDate(schedule: schedule, fromDate: now) {
                                // Reschedule for next occurrence using AlarmKit fixed-date alarms
                                let attributes = buildAlarmAttributes(config: config)
                                let uuid = UUID(uuidString: alarmId) ?? UUID()
                                do {
                                    _ = try await manager.schedule(
                                        id: uuid,
                                        configuration: .alarm(
                                            schedule: .fixed(nextOccurrence),
                                            attributes: attributes
                                        )
                                    )
                                } catch {
                                    print("Failed to reschedule recurring alarm \(alarmId): \(error)")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
